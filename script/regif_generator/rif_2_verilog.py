'''
    rif_2_verilog.py
    Register interface description file to verilog converter
'''

from datetime import datetime
import yaml
from string import Template
import sys, getopt, os, time
from dataclasses import dataclass

# Constants
# Help message
HELP_MESSAGE = '''Convert register description file to verilog source.
Usages:rif_2_verilog.py -t <template_file> -i <input_file> -o <output_file>
    -t <template_name>
        Specify the template file.
    -T
        List the verilog templates in the ./src_tmpl folder.
    -i <input_file>
        Specify the register description file.
    -o <output_file>
        Specify the output file.
    -h
        Display this help message.
'''
# File header comment
COMMENT_HEADER = '''    Filename:${outputfile}
    Source:${sourcefile}
    Time:${datetime}

    Generated by register interface generator'''

# Register define
REG_DEFINE = "reg [${width}:0] ${name};\n"
# Register read
REG_READ = "'h${addr}:${read_function} = ${name};\n"
REG_READ_FILL = "${addr}:${read_function} = { {(${padding_bits}){1'b0}}, ${name}}\n"
# Register reset
REG_RESET = "${name} <= ${width}'h0;\n"
# Register write
REG_WRITE = "'h${addr}:begin\n${write_block}end\n"
REG_WRITE_STRB = "if(${write_strobe}[${n}])\n\t${name} <= wdata_s[${end_bit}:${start_bit}];\n"
# Register field define
REG_FIELD_DEFINE = "${dir} wire [${end_bit}:0] ${field},\n"
REG_FIELD_DEFINE_WHOLE = "${dir} reg [${end_bit}:0] ${field},\n"
REG_FIELD_DEFINE_SINGLE = "${dir} wire ${field},\n"
# Register field output
REG_FIELD_ASSIGN = "assign ${field} = ${name}[${bit_range}];\n"
# Register field update
REG_FIELD_UPDATE = "${name}[${bit_range}] <= ${field};\n"

@dataclass
class BlockGenerator():
    template:str

    def __init__(self, template, blockGenerateFunction):
        self.template = template
        self.getBlockContent = blockGenerateFunction

class RegifSrcGenerator():
    def __init__(self, template, desc, srcFileName, outputFileName):
        # Template and description file
        self.__template = template
        self.__desc = desc

        # Info of the file
        self.__sourceFile = srcFileName
        self.__outputFile = outputFileName
        # Parameters
        self.__busWidth = desc['interface']['params']['width']
        self.__readFunctionName = desc['interface']['signals']['read-function']
        self.__writeStrobeName = desc['interface']['signals']['write-strobe']

        # Source file line ending
        if str.find(self.__template, '\r\n') != -1:
            print('Template ending:CRLF')
            self.__ending = '\r\n'
        elif str.find(self.__template, '\n') != -1:
            print('Template return:LF')
            self.__ending = '\n'
        elif str.find(self.__template, '\r') != -1:
            print('Template return:CR')
            self.__ending = '\r'
        else:
            raise RuntimeError('Unable to find a correct line ending in the template file.')

        # Initialize the block generators
        self.__blockGenerators = [
            BlockGenerator('reg_field_define',self.__getFieldDefines),
            BlockGenerator('reg_field_assign',self.__getFieldAssignment),
            BlockGenerator('reg_field_update',self.__getFieldUpdate),

            BlockGenerator('reg_define',self.__getRegDefine),
            BlockGenerator('reg_read',self.__getReadBlock),
            BlockGenerator('reg_write',self.__getWriteBlock),
            BlockGenerator('reg_reset',self.__getResetBlock)
        ]

    def setEnding(self, ending):
        self.__ending = ending

    # Get register signal definations
    

    def __getReadBlock(self, regDesc):
        addr = regDesc['addr']
        name = regDesc['name']
        width = regDesc['width']
        readFunction = self.__readFunctionName

        if self.__busWidth > width:
            paddingBits = self.__busWidth - width
            return Template(REG_READ_FILL).substitute(addr = addr, padding_bits = paddingBits, name = name, read_function = readFunction)
        elif self.__busWidth == width:
            return Template(REG_READ).substitute(addr = addr, name = name, read_function = readFunction)
        else:
            raise RuntimeError('Register width larger than bus width.')

    def __getResetBlock(self, regDesc):
        name = regDesc['name']
        width = regDesc['width'] * 8

        return Template(REG_RESET).substitute(name = name, width = width)

    def __getWriteBlock(self, regDesc):
        name = regDesc['name']
        addr = regDesc['addr']
        bytes = regDesc['width']
        writeStrobe = self.__writeStrobeName

        # Generate byte write enable block
        bweCode = ''
        for i in range(0,bytes):
            startBit = i * 8
            endBit = (i + 1) * 8 - 1

            bweCode += Template(REG_WRITE_STRB).safe_substitute(n = str(i), start_bit = str(startBit), end_bit = str(endBit), write_strobe = writeStrobe)

        bweCode = Template(bweCode).substitute(name = name)

        return Template(REG_WRITE).substitute(addr = addr, write_block = bweCode)

    def __getFieldDefines(self, regDesc):
        if regDesc['whole-field'] == 1:
            direction = 'output'
            end_bit = regDesc['width'] * 8 - 1
            name = regDesc['name']

            return Template(REG_FIELD_DEFINE_WHOLE).substitute(dir = direction, end_bit = end_bit, field = name)

        s = ''

        for v in regDesc['fields']:
            name = v['name']

            # Direction of the field
            if v['type'] == 0:
                direction = 'output'
            elif v['type'] == 1:
                direction = 'input'
            else:
                raise RuntimeError('Invalid field type in field %s' % v['name'])

            # Width of the field
            bitRange = v['bit'].split(':')
            width = int(bitRange[0]) - int(bitRange[1])
            if width == 0:
                s += Template(REG_FIELD_DEFINE_SINGLE).substitute(dir = direction, field = name)
            else:
                s += Template(REG_FIELD_DEFINE).substitute(dir = direction, end_bit = width, field = name)
        return s

    def __getFieldAssignment(self, regDesc):
        s = ''

        # Register name
        regName = regDesc['name']

        for v in regDesc['fields']:
            if v['type'] == 0:
                name = v['name']
                bitRange = v['bit']

                s += Template(REG_FIELD_ASSIGN).substitute(field = name, name = regName, bit_range = bitRange)

        return s

    def __getFieldUpdate(self, regDesc):
        s = ''

        regName = regDesc['name']

        for v in regDesc['fields']:
            if v['type'] == 1:
                name = v['name']
                bitRange = v['bit']

                s += Template(REG_FIELD_UPDATE).substitute(field = name, name = regName, bit_range = bitRange)

        return s

    def __getHeaderComment(self):
        # Get date and time
        dt = time.localtime()
        dt = time.asctime(dt)

        return Template(COMMENT_HEADER).substitute(outputfile = self.__outputFile, sourcefile = self.__sourceFile, datetime = dt)

    def __insertTabAndFormat(self, s, n, tab):
        # Split the string by line
        li = s.splitlines(keepends = False)

        for i in range(1,len(li)):
            li[i] = (tab * n) + li[i]

        return self.__ending.join(li)

    def generateSource(self):
        # Blocks to be substituted
        blocks = ['' for i in range(len(self.__blockGenerators))]

        # Get the content of the blocks
        for v in self.__desc['registers']:
            for i in range(len(self.__blockGenerators)):
                blocks[i] += self.__blockGenerators[i].getBlockContent(v)

        # Insert tab for the blocks and generate substitute dict
        d = {}
        for i in range(len(self.__blockGenerators)):
            # Find the template position first
            pos = str.find(self.__template, self.__blockGenerators[i].template)
            # Then find the last \n or \r
            lastEnding = 0
            for j in range(0, pos):
                if self.__template[pos - j] == '\n' or self.__template[pos - j] == '\r':
                    break
            frontBlank = self.__template[pos-j:pos]
            # Calculate the number of the tabs
            # Tab or several spaces?
            if str.find(frontBlank, '\t') != -1:
                tabs = j
                tab = '\t'
            else:
                tabs = j / 4    # A tab MUST BE equal to four spaces
                tab = '    '

            # Insert tabs
            blocks[i] = self.__insertTabAndFormat(blocks[i], int(tabs), tab)

            d[self.__blockGenerators[i].template] = blocks[i]

        # Add header
        d['header_comment'] = self.__getHeaderComment()

        # Substitute the blocks in the template file
        source = Template(self.__template).substitute(d)

        return source

if __name__ == '__main__':
    # Parse the arguments
    opts, args = getopt.getopt(sys.argv[1:], "hi:Tt:o:")

    for opt,val in opts:
        if opt == '-i':
            inputFile = val
        elif opt == '-t':
            templateName = val
        elif opt == '-o':
            outputFile = val
        elif opt == '-T':
            print('Templates in the ./src_tmpl folder:')
            for root, dirs, files in os.walk("./src_tmpl", topdown=False):
                for name in files:
                    print(name)

            exit()
        else:
            print(HELP_MESSAGE)
            exit()
    
    # Open the desription file
    desc = None
    with open(inputFile, 'r') as f:
        desc = f.read()
        f.close()

        desc = yaml.load(desc, yaml.loader.Loader)

    # Open the template file
    templateFile = 'src_tmpl/%s' % templateName
    template = None
    with open(templateFile, 'r') as f:
        template = f.read()
        f.close()

    # Generate register interface source file
    gen = RegifSrcGenerator(template, desc, inputFile, outputFile)
    regifSource = gen.generateSource()

    # Write to the output file
    with open(outputFile, 'w') as f:
        f.write(regifSource)
        f.close()
