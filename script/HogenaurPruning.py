'''
    HogenaurPruning.py
    Calculate internal register width of CIC filter
'''
from unittest.main import MODULE_EXAMPLES
from scipy.special import comb
import math

from string import Template

import tkinter
from tkinter import *
from tkinter import ttk

class HogenauerPruning():
    R: int
    M: int
    N: int
    B_in: int
    B_out: int
    B_max: int

    def __init__(self, deci_ratio: int, diff_delay: int, order: int, in_bits: int, out_bits: int):
        self.R = deci_ratio
        self.M = diff_delay
        self.N = order

        self.B_in = in_bits
        self.B_out = out_bits

    def __get_h(self, j, k):
        if j <= self.N:
            item = lambda l: pow(-1, l) * comb(self.N, l) * comb(self.N - j + k - self.R * self.M * l, k - self.R * self.M * l)

            sum = 0
            for l in range(0, math.floor(k / (self.R * self.M)) + 1):
                sum += item(l)

            return sum
        elif j > self.N and j < 2 * self.N + 1:
            return pow(-1, k) * comb(2 * self.N + 1 - j, k)
        else:
            raise ValueError('[h Calcuation] Invalid j value.')

    def __get_Fj_square(self, j):
        sum = 0

        if j > 0 and j <= 2 * self.N:
            for k in range(0, 500):
                h = self.__get_h(j, k)
                h_square = pow(h, 2)

                sum += h_square
        elif j == 2 * self.N + 1:
            return 1
        else:
            raise ValueError('[Fj Calcuation] Invalid j value.')

        return sum

    def __get_Bmax(self, bi):
        return math.ceil(self.N * math.log2(self.R * self.M) + bi - 1)

    def get_max_reg_width(self):
        return self.__get_Bmax(self.B_in) + 1

    def __get_sigma_2NP1_square(self):
        E = pow(2, (self.__get_Bmax(self.B_in) - self.B_out + 1))
        # F_(2N+1) = 1
        return (1 / 12) * pow(E, 2) * 1

    def get_Bj_at_stage(self, j):
        tmp = (1 / self.__get_Fj_square(j)) * (6 / self.N) * self.__get_sigma_2NP1_square()
        return math.floor(0.5 * math.log2(tmp))

    def get_integrators(self):
        li = []
        for j in range(1, self.N + 1):
            B = self.get_Bj_at_stage(j)

            width = self.get_max_reg_width() - B

            li.append(width)

        return li

    def get_combs(self):
        li = []
        for j in range(self.N + 1, self.N * 2 + 1):
            B = self.get_Bj_at_stage(j)

            width = self.get_max_reg_width() - B

            li.append(width)

        return li

class CodeGenerator():
    MODULE_TEMPLATE = Template('''// Generated by Lyskamm Hogenaur Pruning CIC generator

module ${module}(
    input  wire ${clk},
    input  wire ${reset},
    input  wire ${ce},

    input  wire [${width_in}-1:0] din,
    output wire [${width_out}-1:0] dout
);

    wire [${width_in}-1:0] ${d_first};
    assign ${d_first} = din;

    ${code_internal}

    assign dout = ${d_last}
endmodule
    ''')

    RESAMPLE_TEMPLATE = Template('''
    reg [15:0] cnt;

    always @(posedge ${clk}, negedge ${reset}) begin
        if(!${reset}) begin
            ${dout} <= 0;
            cnt <= 16'd0;
        end
        else begin
            if(cnt == ${cycles}) begin
                ${dout} <= ${din};
                cnt <= 0;
            end
            else
                cnt <= cnt + 1;
        end
    end
    ''')

    INTEGRATOR_TEMPLATE = Template('''
    integrator #(
        .DW (${width})
    ) integrator_${idx}(
        .clk     (${clk}),
        .reset_n (${reset}),
        .ce      (${ce})
        .din     (${din}),
        .dout    (${dout})
    );
    ''')

    COMB_TEMPLATE = Template('''
    comb #(
        .DW(${width}),
        .M (${delay})
    ) comb_${idx}(
        .clk     (${clk}),
        .reset_n (${reset} ),
        .ce      (${ce}),
        .din     (${din}),
        .dout    (${dout})
    );
    ''')

    __intg_li: list
    __comb_li: list

    def __init__(self, combs, integrators, module_name, clk_name, reset_name, ce_name, N, M, width_in, width_out, fp):
        self.__intg_li = integrators
        self.__comb_li = combs

        self.__module_name = module_name
        self.__clk_name = clk_name
        self.__reset_name = reset_name
        self.__ce_name = ce_name
        self.__N = N
        self.__M = M
        self.__width_in = width_in
        self.__width_out = width_out
        self.__fp = fp

    def generate(self):
        code_internal = ''

        # Generate integrators
        for i, v in enumerate(self.__intg_li):
            intg_code = self.COMB_TEMPLATE.substitute(
                width = str(v),
                clk = self.__clk_name,
                reset = self.__reset_name,
                ce = self.__ce_name,
                din = 'd_' + str(i),
                dout = 'd_' + str(i + 1)
            )

            code_internal += intg_code

        # Generate resample
        resample_code = self.RESAMPLE_TEMPLATE.substitute(
            width = str(v),
            clk = self.__clk_name,
            reset = self.__reset_name,
            ce = self.__ce_name,
            din = 'd_' + str(self.__N),
            dout = 'd_' + str(self.__N + 1)
        )

        code_internal += resample_code

        # Generate combs
        # Generate integrators
        for i, v in enumerate(self.__comb_li):
            comb_code = self.COMB_TEMPLATE.substitute(
                width = str(v),

                clk = self.__clk_name,
                reset = self.__reset_name,
                ce = self.__ce_name,
                din = 'd_' + str(i + self.__N + 1),
                dout = 'd_' + str(i + self.__N + 1),
                delay = str(self.__M)
            )

            code_internal += comb_code

        # Generate overall module
        code = self.MODULE_TEMPLATE.substitute(
            module = self.__module_name,
            clk = self.__clk_name,
            reset = self.__reset_name,
            d_first = 'd_0',
            d_final = 'd_' + str(2 * self.__N + 1),
            width_in = self.__width_in,
            width_out = self.__width_out
        )



# UI Functions
def set_input_area(components: list, container, prompt: str, unit: str, row = 0, start_col = 0):
    components.append(tkinter.Label(container, text = prompt))
    components[len(components) - 1].grid(row = row, column = start_col, padx = 10, sticky = 'w')
    components.append(tkinter.Label(container, text = unit))
    components[len(components) - 1].grid(row = row, column = start_col + 2, padx = 10, sticky = 'w')

    components.append(Text(
        container,
        width = 18, height = 1
    ))
    components[len(components) - 1].grid(row = row, column = start_col + 1, padx = 0, pady = 1, sticky = 'w')

# Callbacks
def calculate():
    # Delete previous data
    items = table.get_children()
    for v in items:
        table.delete(v)

    # Input
    B_in = int(components[2].get('1.0', '1.end'))
    B_out = int(components[5].get('1.0', '1.end'))
    R = int(components[8].get('1.0', '1.end'))
    N = int(components[11].get('1.0', '1.end'))
    M = int(components[14].get('1.0', '1.end'))

    # Calculate
    calc = HogenauerPruning(R, M, N, B_in, B_out)

    intgs = calc.get_integrators()
    combs = calc.get_combs()

    for i, v in enumerate(intgs):
        table.insert('', END, values = (['INTEGRATOR', i, v]))
    for i, v in enumerate(combs):
        table.insert('', END, values = (['COMB', i, v]))

    # Summary info
    registers = sum(intgs) + sum(combs)
    summary_info_str = f'''Maximum data width: {calc.get_max_reg_width()}
Width growth: {calc.get_max_reg_width() - B_in}

Total Registers: {registers}
    '''

    summary_info.set(summary_info_str)

if __name__ == '__main__':
    # GUI
    # Set form
    form_main = tkinter.Tk()
    form_main.title('CIC Filter Hogenaeur Pruning Calculator')
    
    # Set window geometry
    # Size
    init_width = 1000
    init_height = 400

    # Display at the center of the screen
    init_x = (form_main.winfo_screenwidth() - init_width) / 2
    init_y = (form_main.winfo_screenheight() - init_height) / 2

    form_main.geometry(f'{init_width}x{init_height}+{int(init_x)}+{int(init_y)}')
    form_main.resizable(False, False)

    # Components
    components = []

    # Control area
    label_0 = tkinter.Label(form_main, text = 'Parameters')
    label_0.grid(row = 0, column = 0, padx = 10, sticky = 'w')
    # Inputs
    set_input_area(components, form_main, 'Input width (B_in)', 'bits', 1, 0)
    set_input_area(components, form_main, 'Output width (B_out)', 'bits', 2, 0)
    set_input_area(components, form_main, 'Decimation Ratio (R)', '', 3, 0)
    set_input_area(components, form_main, 'Order (N)', '', 4, 0)
    set_input_area(components, form_main, 'Differential Delay (M)', '', 5, 0)
    # Calculate button
    button_calculate = Button(
        form_main,
        command = calculate,
        text = 'Calculate>>',
        height = 1, width = 30
    )
    button_calculate.grid(row = 6, column = 0, padx = 0, pady = 1, columnspan = 3)

    # Verilog generate button
    button_generate = Button(
        form_main,
        command = calculate,
        text = 'Generate Verilog Code',
        height = 1, width = 30
    )
    button_generate.grid(row = 7, column = 0, padx = 0, pady = 1, columnspan = 3)

    # Results
    label_1 = tkinter.Label(form_main, text = 'Results')
    label_1.grid(row = 0, column = 3, padx = 10, sticky = 'w')

    cols = ['type', 'stage', 'width']
    table = ttk.Treeview(
        master = form_main,
        height = 15,
        columns = cols,
        show = 'headings'
    )
    table.grid(row = 1, column = 3, rowspan = 7, padx = 10, pady = 0, sticky = 'w')

    table.heading('type', text = 'Type')
    table.heading('stage', text = 'Stage #')
    table.heading('width', text = 'Data width')
    
    table.column('type', width = 120, minwidth = 100, anchor = 's')
    table.column('stage', width = 120, minwidth = 100, anchor = 's')
    table.column('width', width = 120, minwidth = 100, anchor = 's')

    scroll_table = Scrollbar(form_main, orient='vertical', command=table.yview)
    scroll_table.grid(row = 1, column = 4, padx = 0, pady = 0, rowspan = 6, sticky = 'nw')
    table.configure(yscrollcommand=scroll_table.set)

    # Summary
    label_2 = tkinter.Label(form_main, text = 'Summary')
    label_2.grid(row = 0, column = 5, padx = 10, sticky = 'w')

    summary_info = tkinter.StringVar()
    label_summary = tkinter.Label(form_main, textvariable = summary_info, justify = 'left')
    label_summary.grid(row = 1, column = 5, padx = 10, rowspan = 4, sticky = 'nw')
    summary_info.set('Not calculated')

    form_main.mainloop()